{% extends "base.html" %}
{% block title %}Enregistrement | IA Voice to Text{% endblock %}
{% block body_bg %}#f7f7f7{% endblock %}
{% block extra_head %}
<style>
  * { box-sizing: border-box; }
  body { margin: 0; background: #f7f7f7; color: #1f1f1f; }
  main { display: flex; min-height: 100vh; }
  section { flex: 1; padding: 2rem; display: flex; flex-direction: column; gap: 1.5rem; }
  .left { background: #ffffff; border-right: 1px solid #dee2e6; }
  .right { background: #0b7285; color: #fff; overflow-y: auto; }
  h1 { margin: 0; font-size: 1.8rem; }
  p { margin: 0; line-height: 1.5; }
  .controls { display: flex; gap: 1rem; flex-wrap: wrap; }
  button {
    padding: 0.75rem 1.5rem;
    border: 0;
    border-radius: 8px;
    background: #0b7285;
    color: #fff;
    font-size: 1rem;
    cursor: pointer;
    transition: background 0.2s ease;
  }
  button.secondary { background: #495057; }
  button:hover:not(:disabled) { background: #095d6b; }
  button.secondary:hover:not(:disabled) { background: #343a40; }
  button:disabled { background: #adb5bd; cursor: not-allowed; }
  label { display: flex; flex-direction: column; gap: 0.5rem; font-weight: 600; }
  select, input[type=text] {
    padding: 0.6rem 0.8rem;
    font-size: 1rem;
    border: 1px solid #ced4da;
    border-radius: 6px;
  }
  .status { font-size: 0.95rem; color: #495057; min-height: 1.5rem; }
  audio { width: 100%; margin-top: 0.5rem; }
  .warning { font-size: 0.85rem; color: #c92a2a; }
  .result { background: rgba(255, 255, 255, 0.12); padding: 1.5rem; border-radius: 12px; margin-right: 1rem; margin-bottom: 1.5rem; }
  .result h2 { margin-top: 0; font-size: 1.4rem; }
  pre {
    white-space: pre-wrap;
    word-break: break-word;
    font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, 'Liberation Mono', 'Courier New', monospace;
    background: rgba(0, 0, 0, 0.35);
    padding: 1rem;
    border-radius: 8px;
    max-height: 40vh;
    overflow-y: auto;
  }
  @media (max-width: 960px) {
    main { flex-direction: column; }
    section { border-right: none; border-bottom: 1px solid #dee2e6; }
    .right { border-bottom: none; }
  }
</style>
{% endblock %}
{% block body %}
<main>
  <section class="left">
    <div>
      <h1>Enregistrer un message</h1>
      <p>Captez un mémo vocal depuis votre navigateur, puis envoyez-le à l'API locale pour transcription.</p>
      <p style="font-size:0.85rem;color:#495057;">Fonctionne sur Chrome, Edge, Firefox et la plupart des navigateurs Android. Safari iOS ne gère pas encore l'enregistrement via MediaRecorder.</p>
    </div>
    <div class="controls">
      <button id="start-btn">Démarrer</button>
      <button id="stop-btn" disabled>Stop</button>
      <button id="reset-btn" class="secondary" disabled>Reset</button>
      <button id="send-btn" class="secondary" disabled>Envoyer</button>
    </div>
    <label>
      Modèle utilisé
      <select id="model">
        {% for alias in model_aliases %}
        <option value="{{ alias }}" {% if alias == default_alias %}selected{% endif %}>{{ alias }}</option>
        {% endfor %}
      </select>
    </label>
    <label>
      Langue imposée (optionnel)
      <input id="language" type="text" placeholder="fr, en, ..." />
    </label>
    <label style="flex-direction: row; align-items: center; gap: 0.5rem; font-weight: 500;">
      <input id="vad" type="checkbox" />
      Filtre VAD (réduit les silences)
    </label>
    <label style="flex-direction: row; align-items: center; gap: 0.5rem; font-weight: 500;">
      <input id="word-timestamps" type="checkbox" />
      Horodatages par mot
    </label>
    <div>
      <strong>Pré-écoute :</strong>
      <audio id="player" controls></audio>
    </div>
    <div class="status" id="status">Prêt.</div>
    <div class="warning">L'enregistrement reste local tant que vous n'appuyez pas sur « Envoyer ».</div>
  </section>
  <section class="right">
    <div class="result">
      <h2>Transcription</h2>
      <pre id="text-output">Aucune donnée pour le moment.</pre>
    </div>
    <div class="result">
      <h2>Métadonnées</h2>
      <pre id="meta-output">{{ '{ }' }}</pre>
    </div>
  </section>
</main>
{% endblock %}
{% block extra_scripts %}
<script>
  let mediaRecorder = null;
  let audioChunks = [];
  let audioBlob = null;
  let mediaStream = null;

  const startBtn = document.getElementById('start-btn');
  const stopBtn = document.getElementById('stop-btn');
  const resetBtn = document.getElementById('reset-btn');
  const sendBtn = document.getElementById('send-btn');
  const statusEl = document.getElementById('status');
  const player = document.getElementById('player');
  const textOutput = document.getElementById('text-output');
  const metaOutput = document.getElementById('meta-output');

  function setStatus(message) {
    statusEl.textContent = message;
  }

  async function ensureRecorder() {
    if (mediaRecorder) {
      return;
    }
    try {
      mediaStream = await navigator.mediaDevices.getUserMedia({ audio: true });
      mediaRecorder = new MediaRecorder(mediaStream);
      mediaRecorder.addEventListener('dataavailable', (event) => {
        if (event.data && event.data.size > 0) {
          audioChunks.push(event.data);
        }
      });
      mediaRecorder.addEventListener('stop', () => {
        if (audioChunks.length) {
          audioBlob = new Blob(audioChunks, { type: mediaRecorder.mimeType || 'audio/webm' });
          player.src = URL.createObjectURL(audioBlob);
          sendBtn.disabled = false;
          setStatus('Enregistrement terminé. Vous pouvez envoyer ou recommencer.');
        }
      });
    } catch (err) {
      console.error(err);
      setStatus("Accès au micro refusé ou indisponible.");
      startBtn.disabled = true;
    }
  }

  startBtn.addEventListener('click', async () => {
    await ensureRecorder();
    if (!mediaRecorder) {
      return;
    }
    audioChunks = [];
    audioBlob = null;
    player.removeAttribute('src');
    resetBtn.disabled = true;
    sendBtn.disabled = true;
      mediaRecorder.start();
      setStatus('Enregistrement en cours...');
      startBtn.disabled = true;
      stopBtn.disabled = false;
      resetBtn.disabled = true;
  });

  stopBtn.addEventListener('click', () => {
    if (!mediaRecorder || mediaRecorder.state !== 'recording') {
      return;
    }
    mediaRecorder.stop();
      stopBtn.disabled = true;
      startBtn.disabled = false;
      resetBtn.disabled = false;
      setStatus("Traitement de l'audio...");
  });

  sendBtn.addEventListener('click', async () => {
    if (!audioBlob) {
      setStatus('Aucun enregistrement à envoyer.');
      return;
    }
      setStatus('Envoi en cours...');
      sendBtn.disabled = true;
      resetBtn.disabled = true;

    const formData = new FormData();
    formData.append('file', audioBlob, 'recording.webm');
    formData.append('model', document.getElementById('model').value);

    const language = document.getElementById('language').value.trim();
    if (language) {
      formData.append('language', language);
    }
    if (document.getElementById('vad').checked) {
      formData.append('vad', 'true');
    }
    if (document.getElementById('word-timestamps').checked) {
      formData.append('word_timestamps', 'true');
    }

    try {
      const response = await fetch('/transcribe', {
        method: 'POST',
        body: formData,
      });
      if (!response.ok) {
        const text = await response.text();
        throw new Error(`Erreur ${response.status}: ${text}`);
      }
      const data = await response.json();
      textOutput.textContent = data.text || '(réponse vide)';
      metaOutput.textContent = JSON.stringify(data, null, 2);
      setStatus('Transcription réussie.');
    } catch (err) {
      console.error(err);
      setStatus(`Erreur: ${err.message}`);
    } finally {
      sendBtn.disabled = false;
      resetBtn.disabled = false;
    }
  });

  resetBtn.addEventListener('click', () => {
    if (mediaRecorder && mediaRecorder.state === 'recording') {
      return;
    }
    audioChunks = [];
    audioBlob = null;
    if (player.src) {
      URL.revokeObjectURL(player.src);
    }
    player.removeAttribute('src');
    textOutput.textContent = 'Aucune donnée pour le moment.';
    metaOutput.textContent = '{ }';
    setStatus('Prêt.');
    sendBtn.disabled = true;
    resetBtn.disabled = true;
  });

  window.addEventListener('beforeunload', () => {
    if (mediaStream) {
      mediaStream.getTracks().forEach(track => track.stop());
    }
  });
</script>
{% endblock %}
